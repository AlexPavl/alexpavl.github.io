# SOLID
SOLID принцип это сет подходов которые стоит применять при проектировании структуры или класса в ООП.
- Single Responsibility Principle (делай модули меньше)
- Open-Closed Principle (делай модули расширяемыми)
- Liskov Substitution Principle (наследуй правильно/логично)
- Interface Segregation Principle (делай интерфейсы маленькими)
- Dependency Inversion Principle (используй интерфейсы а не объекты)

Соответственно название берется из первых букв каждого из принципов.

## The Single Responsibility Principle
Каждый класс должен делать одну определенную вещь и соответственно иметь только причину для изменения.

Если рассматривать принцип с более технической стороны: лишь одно потенциальное изменение (логика в базе данных, логировании и тп) в спецификации может повлиять на спецификацию класса.

Следование принципу единой ответственности важно. 
Во-первых многие команды могут работать над одним проектом и соответственно, будет меньше причин лезть в один класс.
Во-вторых это делает контроль версий проще. Так как в истории коммитов мы можем увидеть когда меняли конкретный класс.
В-третьих будет меньше конфликтов при пул реквестах даже при изменении одного файла, так как опять же, маловероятно столкновение изменений в конкретном классе.

Рассмотрим пример применения принципа через плохой дизайн:
```cpp
class Customer {
private:
  string name;
  int id;
  vector<Item> items;
  float totalAmount;
public:
  void setName(string name);
  string getName();
  void setId(int id);
  int getId();
  void addItem(Item item);
  void removeItem(Item item);
  float calculateTotalAmount();
  string generateInvoice();
};
```
Как видно из кода, Customer ответственен за хранение информации о заказчике, но также производит расчет и генерирует инвойс, таким образом если формат инвойса будет меняться или будут изменения в calculateTotalAmount то придется менять полностью класс, чтобы это исправить можем разделить обязанности на другие классы:

```cpp
class CustomerDetails {
private:
  string name;
  int id;
public:
  void setName(string name);
  string getName();
  void setId(int id);
  int getId();
};

class BillingCalculator {
private:
  vector<Item> items;
public:
  void addItem(Item item);
  void removeItem(Item item);
  float calculateTotalAmount();
};

class InvoiceGenerator {
public:
  string generateInvoice(CustomerDetails customerDetails, BillingCalculator billingCalculator);
};
```
Таким образом мы разделили информацию по покупателю в один класс, по списку его покупок в другой, вместе с составлением полного списка и итоговой стоимости в другой и производим инвойс в третьем. Такая архитектура лучше подходит под SRP.

## The Open-Closed Principle
Открытый-закрытый принцип говорит о том что класс должен быть закрыт для модификаций но открыт для расширения. Позволяет сохранить код более гибким и легче его поддерживать. 

В С++ это можно реализовать с использованием наследования, полиморфизма и интерфейсов. 
Предположим у нас есть следующая иерархия классов:
```cpp
class Shape {
public:
  virtual double area() = 0;
};

class Rectangle : public Shape {
private:
  double width;
  double height;
public:
  Rectangle(double width, double height);
  double area() override;
};

class Circle : public Shape {
private:
  double radius;
public:
  Circle(double radius);
  double area() override;
};

class Triangle : public Shape {
private:
  double base;
  double height;
public:
  Triangle(double base, double height);
  double area() override;
};
```
Предположим, мы хотим добавить новый класс Square, мы можем добавить это изменив Shape класс или создать новый класс наследник:
```cpp
class Square : public Shape {
private:
  double side;
public:
  Square(double side);
  double area() override;
};
```
Не изменив уже существующий код мы расширяем возможности.

Грубо говоря, принцип говорит о том что чаще надо использовать различные интерфейсы или чисто виртуальные классы и расширять их с помощью наследования

## The Liskov Substitution Principle
В кратце, принцип говорит что у классов наследника и базового должно быть логичное поведение, то есть пингвин хоть и птица, но летать не может.

Если в коде программы Базовый класс заменить на его Наследника, то программа должна работать, так как в Наследнике есть все операции, которые были в Базовом. В Базовый класс нужно выносить только общую логику, которую наследники будут реализовывать. Наследников создаем только тогда, когда они правильно реализуют логику Базового класса.

## The Interface Segregation Principle
Клиенты не должны зависеть от интерфейсов, которые они не используют. Большие интерфейсы следует разбивать на интерфейсы поменьше. Так клиенты смогут использовать только те интерфейсы, которые им нужны. Это делает менее связанный код, уменьшает зависимости между элементами системы, упрощает изменения в коде.

То есть, создавайте интерфейсы только те, которые нужны пользователям, разбивать на более мелкие.

## The Dependency Inversion Principle
Зависьте от интерфейсов, а не от конкретных классов. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Интерфейсы не должны зависеть от реализации, а вот реализация должна зависеть от интерфейсов.

Тут опять же идея чтобы использовать некоторые интерфейсы для хранения и использования внутри классов (через ссылки или указатели). Для лучшей масштабируемости

## Выводы
Изучив подробнее этот вопрос, это какой-то максималистский подход. Та же штука как с паттернами проектирования - прочитал и решил что надо везде использвать, даже там где они нахер ненужны. Если у вас один класс, который пишет в файл и не предвидится хоть какое-то изменение вообще, нет смысла добавлять новый уровень абстракции чтобы угодить тенденциям написания кода.